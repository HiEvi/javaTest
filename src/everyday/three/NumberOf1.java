package everyday.three;

/**
 * 题目描述
 * 输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。
 * 暴力法：除2取模法，缺点：对于-2147483648,二进制为1000...000，一共有31个0.因为计算机使用补码存储二进制数据的。对于这个数据，我们的方***输出0，实际上为1.所以这种方法不对。
 * 二进制位移：
 * 直接将整数看成二进制，然后采用移位的方法。
 *
 * int val; // input data
 * int ans = 0;
 * while (val != 0) {
 *     if (val & 1) ++ans;
 *     val >>= 1;
 * }
 * 代码中val & 1表示val 与 0x000...0001（其中有31个0）进行 & 操作。
 * val >>= 1表示，如果val的二进制是110，则操作之后会变成011,也就是舍去最低位，然后最高位补0.
 * 但是如果val为负数，最高位会补1，所以对于负数还是有点问题。
 * 我们可以转换一下思路，让一个数0x01从右向左与val的每一位进行&操作来判断
 *
 * int val; // input data
 * int ans = 0;
 * int mark = 0x01;
 * while (mark != 0) {
 *     if (mark & val) ++ans;
 *     mark <<= 1;
 * }
 * 这个算法可以解决此题，但是需要运行32次。
 * 时间复杂度：O(32)
 * 空间复杂度：O(1)
 *
 *
 * 技巧法：
 * 对于上一种解法中，无用操作是，如果当前位是0， 还是会做判断，然后一位一位的移动。
 * 如果，给你一种超能力，你一下可以对从右向左的第一位1直接判断，遇到0直接略过，那效率是不是很快。
 *
 * 现考虑二进制数：val :1101000, val-1: 1100111 那么val & （val-1） : 1100000
 * 如果你会了这个操作，是不是这题就很简单了。
 *
 * int val; // input data
 * int ans = 0;
 * while (val != 0) {
 *     ++ans;
 *     val = val & (val-1);
 * }
 * 时间复杂度：O(32)
 * 空间复杂度：O(1)
 */
public class NumberOf1 {
    public int NumberOf1(int n) {
        int result = 0;
        while (n != 0) {
            ++result;
            n = n & (n-1);
        }
        return result;
    }
}
